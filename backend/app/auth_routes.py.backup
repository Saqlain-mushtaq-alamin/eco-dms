"""
Configuration management for decentralized backend.
Loads environment variables for IPFS and Pinata integration.
"""
from pydantic_settings import BaseSettings
from typing import List, Union
from pydantic import field_validator


class Settings(BaseSettings):
    """
    Application settings loaded from .env file.
    No more database URLs - we're using IPFS for storage!
    """
    
    # API Configuration
    API_V1_STR: str = "/api/v1"
    PROJECT_NAME: str = "Eco-DMS Decentralized"
    
    # IPFS Configuration - connects to local IPFS node
    IPFS_API_URL: str = ""
    IPFS_GATEWAY_URL: str = "https://gateway.pinata.cloud/ipfs/"
    
    # Pinata - pins content to prevent garbage collection
    PINATA_API_KEY: str = ""
    PINATA_SECRET_KEY: str = ""
    PINATA_JWT: str = ""
    
    # JWT Configuration - for session management
    JWT_SECRET_KEY: str = "change-this-secret-key"
    JWT_ALGORITHM: str = "HS256"
    JWT_EXPIRATION_MINUTES: int = 1440  # 24 hours
    
    # CORS - frontend access control
    ALLOWED_ORIGINS: Union[str, List[str]] = [
        "http://localhost:3000",
        "http://localhost:5173",
    ]
    
    # Chain ID (1 = Ethereum mainnet, 11155111 = Sepolia testnet)
    CHAIN_ID: int = 1
    
    @field_validator('ALLOWED_ORIGINS', mode='before')
    @classmethod
    def parse_cors_origins(cls, v):
        """
        Parse ALLOWED_ORIGINS from various formats.
        Supports:
        - JSON array: ["http://localhost:3000","http://localhost:5173"]
        - Comma-separated: http://localhost:3000,http://localhost:5173
        - Single string: http://localhost:3000
        """
        if isinstance(v, str):
            # Remove whitespace and brackets
            v = v.strip()
            
            # If it's a JSON-like string, try to parse it
            if v.startswith('[') and v.endswith(']'):
                import json
                try:
                    return json.loads(v)
                except:
                    # Remove brackets and split
                    v = v[1:-1]
            
            # Split by comma
            if ',' in v:
                return [origin.strip().strip('"').strip("'") for origin in v.split(',')]
            
            # Single origin
            return [v] if v else []
        
        return v
    
    class Config:
        env_file = ".env"
        case_sensitive = True


# Global settings instance
settings = Settings()

"""
Authentication routes using SIWE (Sign-In with Ethereum).
No passwords, no database - just wallet signatures!
"""
from fastapi import APIRouter, HTTPException, Depends, Response
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import jwt, JWTError
from datetime import datetime, timedelta
import secrets
from urllib.parse import urlparse
from web3 import Web3
from eth_account.messages import encode_defunct

from .models import (
    NonceRequest,
    NonceResponse,
    VerifyRequest,
    TokenResponse,
    ProfileUpdateRequest
)
from .services.user_service import user_service
from .config import settings

router = APIRouter(prefix="/auth", tags=["Authentication"])
security = HTTPBearer()

# In-memory nonce storage
# Maps wallet_address -> {nonce, timestamp}
# In production, use Redis or on-chain storage
nonce_store = {}

def build_siwe_message(addr: str, chain_id: int, nonce: str) -> str:
    """
    Build SIWE-compliant message for signing.
    
    Args:
        addr: Wallet address
        chain_id: Blockchain chain ID (1 for Ethereum mainnet)
        nonce: Random nonce for this session
        
    Returns:
        Formatted SIWE message string
    """
    # Safely get configuration values with fallbacks
    uri = (
        getattr(settings, "URI", None)
        or getattr(settings, "BASE_URI", None)
        or getattr(settings, "API_URL", None)
        or getattr(settings, "FRONTEND_URL", None)
        or getattr(settings, "BACKEND_URL", None)
        or getattr(settings, "BASE_URL", None)
        or "http://localhost:8000"
    )
    
    parsed = urlparse(uri)
    domain = getattr(settings, "DOMAIN", None) or (parsed.netloc or "localhost")
    version = getattr(settings, "VERSION", "1")
    
    return (
        f"{domain} wants you to sign in with your Ethereum account:\n"
        f"{addr}\n\n"
        f"Sign in to Eco-DMS\n\n"
        f"URI: {uri}\n"
        f"Version: {version}\n"
        f"Chain ID: {chain_id}\n"
        f"Nonce: {nonce}\n"
        f"Issued At: {datetime.utcnow().isoformat()}Z"
    )


@router.post("/nonce", response_model=NonceResponse)
async def get_nonce(request: NonceRequest):
    """
    Step 1: Get nonce for SIWE authentication.
    
    Flow:
    1. Frontend requests nonce with wallet address
    2. Backend generates random nonce
    3. Frontend signs message with nonce using wallet
    4. Backend verifies signature in /verify endpoint
    
    Example request:
        POST /auth/nonce
        {"wallet_address": "0x1234..."}
        
    Example response:
        {
            "nonce": "abc123xyz789",
            "message": "localhost wants you to sign in..."
        }
    """
    # Validate wallet address format
    if not Web3.is_address(request.wallet_address):
        raise HTTPException(status_code=400, detail="Invalid Ethereum address")
    
    wallet_address = Web3.to_checksum_address(request.wallet_address)

    # Generate random nonce (prevents replay attacks)
    nonce = secrets.token_hex(16)

    # Store nonce with timestamp (expires after 5 minutes)
    nonce_store[wallet_address.lower()] = {
        "nonce": nonce,
        "timestamp": datetime.utcnow()
    }

    # Build SIWE message with default chain ID
    default_chain_id = getattr(settings, "CHAIN_ID", 1)
    message = build_siwe_message(wallet_address, default_chain_id, nonce)

    return NonceResponse(nonce=nonce, message=message)


@router.post("/verify", response_model=TokenResponse)
async def verify_signature(request: VerifyRequest, response: Response):
    """
    Step 2: Verify wallet signature and issue JWT token.
    Uses Web3.py for signature verification.
    """
    # Validate wallet address
    if not Web3.is_address(request.wallet_address):
        raise HTTPException(status_code=400, detail="Invalid Ethereum address")
    
    wallet_address = Web3.to_checksum_address(request.wallet_address).lower()

    # Check if nonce exists
    if wallet_address not in nonce_store:
        raise HTTPException(status_code=400, detail="Nonce not found. Request a new nonce.")

    nonce_data = nonce_store[wallet_address]

    # Check nonce expiration (5 minutes)
    if (datetime.utcnow() - nonce_data["timestamp"]).total_seconds() > 300:
        del nonce_store[wallet_address]
        raise HTTPException(status_code=400, detail="Nonce expired. Request a new nonce.")

    try:
        # Verify signature using Web3.py
        w3 = Web3()
        
        # Encode message for signature verification
        message = encode_defunct(text=request.message)
        
        # Recover signer address from signature
        recovered_address = w3.eth.account.recover_message(message, signature=request.signature)
        
        # Verify recovered address matches claimed wallet
        if recovered_address.lower() != wallet_address:
            raise HTTPException(
                status_code=400, 
                detail=f"Signature verification failed. Expected {wallet_address}, got {recovered_address.lower()}"
            )

        # Verify message contains correct nonce
        if nonce_data["nonce"] not in request.message:
            raise HTTPException(status_code=400, detail="Invalid nonce in message")

        # Delete used nonce (prevent replay attacks)
        del nonce_store[wallet_address]

        # Get or create user profile in IPFS
        profile, profile_cid = await user_service.get_or_create_profile(wallet_address)

        # Create JWT token
        token_data = {
            "sub": wallet_address,
            "exp": datetime.utcnow() + timedelta(minutes=settings.JWT_EXPIRATION_MINUTES)
        }

        access_token = jwt.encode(
            token_data,
            settings.JWT_SECRET_KEY,
            algorithm=settings.JWT_ALGORITHM
        )

        return TokenResponse(
            access_token=access_token,
            token_type="bearer",
            wallet_address=wallet_address
        )

    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Signature verification failed: {str(e)}")


async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> str:
    """
    Dependency to get current authenticated user from JWT token.
    
    Usage in routes:
        @router.get("/profile")
        async def get_profile(wallet: str = Depends(get_current_user)):
            # wallet contains authenticated user's address
            pass
    """
    try:
        # Decode JWT token
        payload = jwt.decode(
            credentials.credentials,
            settings.JWT_SECRET_KEY,
            algorithms=[settings.JWT_ALGORITHM]
        )

        sub = payload.get("sub")

        if not isinstance(sub, str) or not sub:
            raise HTTPException(status_code=401, detail="Invalid token")

        return sub.lower()

    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid or expired token")


@router.get("/me")
async def get_current_user_profile(wallet_address: str = Depends(get_current_user)):
    """
    Get current user's profile from IPFS.
    
    Requires authentication (JWT token in header).
    
    Example request:
        GET /auth/me
        Authorization: Bearer eyJhbGc...
        
    Example response:
        {
            "wallet_address": "0x1234...",
            "username": "alice",
            "bio": "Eco enthusiast",
            "avatar_cid": "QmXyz...",
            "following": ["0x5678..."],
            "followers": ["0x9abc..."]
        }
    """
    profile = await user_service.get_profile(wallet_address)

    if not profile:
        # Create profile if doesn't exist
        profile, _ = await user_service.get_or_create_profile(wallet_address)

    return profile


@router.put("/profile")
async def update_profile(
    update_data: ProfileUpdateRequest,
    wallet_address: str = Depends(get_current_user)
):
    """
    Update user profile.
    
    Requires authentication.
    
    Example request:
        PUT /auth/profile
        Authorization: Bearer eyJhbGc...
        {
            "username": "alice_eco",
            "bio": "Saving the planet one document at a time üåç"
        }
        
    Example response:
        {
            "success": true,
            "new_profile_cid": "QmNewCid123...",
            "message": "Profile updated successfully"
        }
    """
    new_cid = await user_service.update_profile(
        wallet_address,
        username=update_data.username,
        bio=update_data.bio,
        avatar_cid=update_data.avatar_cid
    )

    if not new_cid:
        raise HTTPException(status_code=500, detail="Failed to update profile")

    return {
        "success": True,
        "new_profile_cid": new_cid,
        "message": "Profile updated successfully"
    }


@router.post("/logout")
def logout(response: Response):
    """
    Logout user (clears session).
    
    Note: JWT tokens are stateless, so we can't truly "invalidate" them.
    Frontend should delete the token from storage.
    
    Example request:
        POST /auth/logout
        
    Example response:
        {"ok": true}
    """
    return {"ok": True, "message": "Logged out successfully"}